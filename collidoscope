import uharfbuzz as hb
import re
from pathlib import Path
from fontTools.ttLib import TTFont
from beziers.path import BezierPath
from beziers.path.geometricshapes import Rectangle
from beziers.point import Point
from beziers.boundingbox import BoundingBox
import sys
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

parser = ArgumentParser()
parser.add_argument("input",
                    help="font file to process", metavar="OTF")
parser.add_argument('-c', type=int, default=3, dest="context",
                    help="number of glyphs to process", metavar="CONTEXT")
parser.add_argument('--no-faraway', action='store_false', dest="faraway",
                    help="don't check for interactions between non-adjacent glyphs")
parser.add_argument('--cursive', action='store_true', dest="cursive",
                    help="check for interactions between paths without anchors")
parser.add_argument('--area', type=int, default=0, dest="area",
                    help="check for interactions of size >=area%% between paths")

parser.add_argument('-r', dest="range",
                    help="Comma-separated list of Unicode ranges", metavar="RANGE")

args = parser.parse_args()

report = open("report.html", "w")

fontfilename = args.input
font = TTFont(fontfilename)
blank = Path(fontfilename).read_bytes()

def prep_shaper(fontfilename):
    face = hb.Face(blank)
    font = hb.Font(face)
    upem = face.upem
    font.scale = (upem, upem)
    hb.ot_font_set_funcs(font)
    return font

def shape_a_text(hbfont, text):
    buf = hb.Buffer()
    buf.add_str(text)
    buf.guess_segment_properties()
    hb.shape(hbfont, buf)
    return buf

def bb2path(bb):
    vec = bb.tr-bb.bl
    return Rectangle(vec.x, vec.y, origin= bb.bl+vec*0.5)

def get_anchors(font):
    glyf = font["glyf"]
    # Find the GPOS CursiveAttachment lookups
    cursives = filter(lambda x: x.LookupType==3, font["GPOS"].table.LookupList.Lookup)
    anchors = {}
    for c in cursives:
        for s in c.SubTable:
            for glyph, record in zip(s.Coverage.glyphs, s.EntryExitRecord):
                anchors[glyph] = []
                if record.EntryAnchor:
                    anchors[glyph].append( (record.EntryAnchor.XCoordinate, record.EntryAnchor.YCoordinate) )
                if record.ExitAnchor:
                    anchors[glyph].append( (record.ExitAnchor.XCoordinate, record.ExitAnchor.YCoordinate) )
    return anchors

anchors = get_anchors(font)

glyphcache = {}

def get_cached_glyph(name):
    if name in glyphcache: return glyphcache[name]
    paths = BezierPath.fromFonttoolsGlyph(font, name)
    pathbounds = []
    paths = list(filter(lambda p: p.area > 0, paths))
    for p in paths:
        p.hasAnchor = False
        p.glyphname = name
        if name in anchors:
            for a in anchors[name]:
                if p.pointIsInside(Point(*a)): p.hasAnchor = True
        bounds = p.bounds()
        pathbounds.append(bounds)

    glyphbounds = BoundingBox()
    if pathbounds:
        for p in pathbounds:
            glyphbounds.extend(p)
    else:
        glyphbounds.tr = Point(0,0)
        glyphbounds.bl = Point(0,0)
    glyphcache[name] = {
        "name": name,
        "paths": paths,
        "pathbounds": pathbounds,
        "glyphbounds": glyphbounds,
        "pathconvexhull": None # XXX
    }
    assert(len(glyphcache[name]["pathbounds"]) == len(glyphcache[name]["paths"]))
    return glyphcache[name]

def get_positioned_glyph(name, pos):
    g = get_cached_glyph(name)
    positioned = {
        "name": g["name"],
        "paths": [ p.clone().translate(pos) for p in g["paths"] ],
        "pathbounds": [b.translated(pos) for b in g["pathbounds"]],
        "glyphbounds": g["glyphbounds"].translated(pos),
    }
    assert(len(positioned["pathbounds"]) == len(positioned["paths"]))
    # Copy path info
    for old,new in zip(g["paths"], positioned["paths"]):
        new.hasAnchor = old.hasAnchor
        new.glyphname = old.glyphname
    return positioned

def find_overlapping_paths(g1, g2):
    if not (g1["glyphbounds"].overlaps(g2["glyphbounds"])): return []
    # print("Glyph bounds overlap")

    overlappingPathBounds = []
    for ix1,p1 in enumerate(g1["pathbounds"]):
        for ix2,p2 in enumerate(g2["pathbounds"]):
            if p1.overlaps(p2):
                # print("Path bounds overlap ", ix1, ix2)
                overlappingPathBounds.append( (ix1,ix2) )

    if not overlappingPathBounds: return []

    overlappingPaths = []
    for ix1, ix2 in overlappingPathBounds:
        p1 = g1["paths"][ix1]
        p2 = g2["paths"][ix2]
        for s1 in p1.asSegments():
          for s2 in p2.asSegments():
            if len(s1.intersections(s2))>0:
                overlappingPaths.append((p1,p2))

    return overlappingPaths

def get_glyphs(hbfont, font, text, anchors):
    buf = shape_a_text(hbfont, text)
    glyf = font["glyf"]
    cursor = 0
    glyphs = []
    ix = 0
    for info, pos in zip(buf.glyph_infos, buf.glyph_positions):
        position = Point(cursor + pos.position[0], pos.position[1])

        name = glyf.getGlyphName(info.codepoint)
        g = get_positioned_glyph(name, position)
        g["advance"] = pos.position[2]
        for p in g["paths"]:
            p.origin = info.cluster
            p.glyphIndex = ix
        glyphs.append(g)
        ix = ix + 1
        cursor = cursor + pos.position[2]
    return glyphs

def draw_overlaps(glyphs, overlaps, filename):
    fig, ax = plt.subplots()
    for p1,p2 in overlaps:
        intersect = p1.intersection(p2)
        for ix, g in enumerate(glyphs):
            col = "bgrcmy"
            for p in g["paths"]:
                p.clone().plot(ax, drawNodes = False, color=col[ix], fill = p.hasAnchor)
            # for p in g["pathbounds"]:
                # bb2path(p).plot(ax, fill= False, drawNodes = False, color=col[ix])

        for i in intersect: i.clone().plot(ax, fill= True, drawNodes = False)
    plt.axis('off')
    plt.savefig(filename)
    plt.close(fig)

def has_collisions(glyphs, counter, rules):
    # Rules for collision detection:
    #   "Far away" (adjacency > 1) glyphs should not interact at all
    if rules["faraway"]:
        for firstIx, first in enumerate(glyphs):
            nonAdjacent = firstIx+2
            while nonAdjacent < len(glyphs):
                if glyphs[nonAdjacent]["advance"] == 0:
                    nonAdjacent = nonAdjacent+1
                else: break
            for secondIx in range(nonAdjacent,len(glyphs)):
                second = glyphs[secondIx]
                overlaps = find_overlapping_paths(first, second)
                if not overlaps: continue
                draw_overlaps(glyphs, overlaps, 'col-%06i.png' % counter)
                return True

    #   Where there anchors between a glyph pair, the anchored paths should be
    #   allowed to collide but others should not
    # XX this rule does not work when cursive attachment is used occasionally
    for firstIx in range(0,len(glyphs)):
        first = glyphs[firstIx]
        firstHasAnchors = any([x.hasAnchor for x in first["paths"]])
        second = glyphs[firstIx+1]
        if rules["cursive"]:
            secondHasAnchors = any([x.hasAnchor for x in first["paths"]])
            if firstHasAnchors or secondHasAnchors:
                overlaps = find_overlapping_paths(first, second)
                overlaps = list(filter(lambda x: ((x[0].hasAnchor and not x[1].hasAnchor) or (x[1].hasAnchor and not x[0].hasAnchor)), overlaps))
                if not overlaps: continue
                draw_overlaps(glyphs, overlaps, 'col-%06i.png' % counter)
                return True
        if rules["area"]:
            overlaps = find_overlapping_paths(first, second)
            if not overlaps: continue
            newoverlaps = []
            for p1,p2 in overlaps:
                intersect = p1.intersection(p2)
                for i in intersect:
                    ia = i.area
                    if ia > p1.area * rules["area"] or ia > p2.area*rules["area"]:
                        print("Intersect area: %i, path1 area: %i, path2 area: %i" % (ia,p1.area,p2.area))
                        newoverlaps.append((p1,p2))
            if newoverlaps:
                draw_overlaps(glyphs, newoverlaps, 'col-%06i.png' % counter)
                return True
    return False

codepoints = font["cmap"].getBestCmap().keys()
codepointfilter = []
if args.range:
    for r in args.range.split(","):
        if "-" in r:
            first, last = r.split("-")
            codepointfilter.extend(range(int(first, 16),int(last,16)+1))
        else:
            codepointfilter.append(int(r,16))
    codepoints = list(filter(lambda x: x in codepointfilter, codepoints))
else:
    print("Testing ALL GLYPHS AGAINST ALL GLYPHS - you may want to specify a -r range e.g. -r 0620-064A")
combinations = []
count = 1

for i in range(0,args.context):
    combinations.append(codepoints)
    count = count * len(codepoints)

import itertools

report.write('''
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"> 
    <title></title>
<style>
        .cards {
display: grid;
grid-template-columns: repeat(auto-fill, 250px);
grid-auto-rows: auto;
grid-gap: 1rem;
font-family:'%s'; font-size:50pt;
}
 
 
.card {
border: 2px solid #e7e7e7;
border-radius: 4px;
padding: .5rem;
}</style>
</head>

<body>
<h2>Collision Report</h2>
<div class="cards">
''' %  font["name"].getDebugName(1))

counter = 0
for element in itertools.product(*combinations):
    hbfont = prep_shaper(fontfilename)
    text = "".join(map(chr, element))
    if counter % 100 == 0:
        sys.stderr.write("%s (%i/%i = %i%%)\n" % (text, counter, count, counter/count*100))
    glyphs = get_glyphs(hbfont, font, text, anchors)
    if has_collisions(glyphs, counter, {
        "faraway": args.faraway,
        "cursive": args.cursive,
        "area":    args.area / 100
    }):
        report.write("<div class=\"card\"> %s <img src=\"col-%06i.png\" width=\"200\"></div> \n" % (text, counter))
        report.flush()
    counter = counter + 1

report.write('''
</div>
</body>
</html>
''')